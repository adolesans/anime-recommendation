# -*- coding: utf-8 -*-
"""Proyek Anime Recommendation|MLT2 Dicoding.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l_4RwxkkhbiAYOrGAVjOxW7sgvKgCfdb

# Model Sistem Rekomendasi Anime

* Nama : Annisa Dewiyanti
* ID Dicoding : andwynt
* Dataset: https://www.kaggle.com/datasets/CooperUnion/anime-recommendations-database
* Domain : Rekomendasi Fim Annimasi (*Anime*)

# 1. Data Understanding

## Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
import zipfile
import tensorflow as tf
import pandas as pd
import numpy as np
import seaborn as sns
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
# %matplotlib inline
from keras.callbacks import EarlyStopping
from google.colab import files
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""## Download Dataset"""

!pip install -q kaggle

uploaded = files.upload()

!chmod 600 /content/kaggle.json
! KAGGLE_CONFIG_DIR=/content/ kaggle datasets download -d CooperUnion/anime-recommendations-database

local_zip = '/content/anime-recommendations-database.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/content')
zip_ref.close()

"""dalam folder anime-recommendations-database.zip terdapat dua file yang dibutuhkan

1. anime.csv
2. rating.csv
"""

anime = pd.read_csv("/content/anime.csv")
ratings = pd.read_csv("/content/rating.csv")

print(f'Jumlah data anime: {anime.shape[0]}')
print(f'Jumlah variabel pada data anime: {anime.shape[1]} variabel')
print(f'Jumlah data ratings: {ratings.shape[0]}')
print(f'Jumlah variabel pada data ratings: {ratings.shape[1]} variabel')

"""# Data Understanding

* Dataset Anime
"""

anime.head()

"""Variable dataset movies terbagi 3 yakni:

* anime_id -> ID anime
* name -> Judul anime
* genres -> Genre anime
* type -> Tipe anime
* episodes -> Episode anime
* rating -> Nilai dari anime
* members -> jumlah komunitas dari anime tersebut
"""

anime.info()

print(f'Cek Duplikasi Dataset Anime: {anime.duplicated().sum()} duplikasi')

print(f'Cek Missing Value Pada Variable Dataset Anime:')
print(f'- anime_id sebanyak {anime.anime_id.isnull().sum()}')
print(f'- name sebanyak {anime.name.isnull().sum()}')
print(f'- genre sebanyak {anime.genre.isnull().sum()}')
print(f'- type sebanyak {anime.type.isnull().sum()}')
print(f'- episodes sebanyak {anime.episodes.isnull().sum()}')
print(f'- rating sebanyak {anime.rating.isnull().sum()}')
print(f'- members sebanyak {anime.members.isnull().sum()}')

"""* Dataset Ratings"""

ratings.head()

"""**insight**

Variable dataset ratings terbagi 3 yaitu:

* **user_id**-> ID User pemberi rating
* **anime_id** -> ID film yang dirating
* **rating** -> Rating film yang diberikan user
"""

ratings.info()

ratings.describe()

"""**insight**

setelah dicek, didapatkan informasi skala dari rating film yakni rating  -1 dan rating tertinggi adalah 10.
"""

print(f'Cek Missing Value Pada Variable Dataset Rating:')
print(f'- user_id sebanyak {ratings.user_id.isnull().sum()}')
print(f'- anime_id sebanyak {ratings.anime_id.isnull().sum()}')
print(f'- rating sebanyak {ratings.rating.isnull().sum()}')

print(f'Cek Duplikasi Dataset Ratings: {ratings.duplicated().sum()} duplikasi')

"""# 2. Data Preparation

## Sorting Data Rating Berdasarkan User ID Kemudian Menjadikan integer
"""

ratings = ratings.sort_values('user_id').astype('int')

"""## Pembersihan Missing Value

* Menghapus missing value pada dataset anime.
"""

anime.isna().sum()

anime = anime.dropna()

anime.isna().sum()

"""## Menghapus symbol pada judul anime"""

import re
def text_cleaning(text):
    text = re.sub(r'"', '', text)
    text = re.sub(r'.hack//', '', text)
    text = re.sub(r'\'', '', text)
    text = re.sub(r'A\'s', '', text)
    text = re.sub(r'I\'', 'I\'', text)
    text = re.sub(r'&', 'and', text)

    return text

anime.loc[:, 'name'] = anime['name'].apply(text_cleaning)

"""## Pembersihan Duplikasi Data"""

ratings.drop_duplicates(subset=['user_id','anime_id'], keep='first', inplace=True)

"""##Penggabungan Dataset"""

merge_dataset = pd.merge(ratings, anime, how='left', on='anime_id')
animerating = merge_dataset.copy()
animerating.head()

animerating = animerating.drop('rating_x', axis=1)
animerating.head()

"""menghapus missing values dan duplicated data setelah dataset digabungkan lalu mengapus variabel yang tidak dibutuhkan (`rating_x`)"""

animerating = animerating[~pd.isnull(animerating['genre'])]

print(f'Setelah menggabungkan dataset dan menghapus missing values didapatkan:')
print(f'- {animerating.shape[0]} baris data')
print(f'- {animerating.shape[1]} kolom / variable')

anime.describe().apply(lambda s: s.apply('{0:.2f}'.format))

"""**insight**

Dataset anime ini menampilkan variasi rating yang jelas, dari 1.67 sampai 10, dengan nilai tengah 6.48. Lebih jauh, jumlah anggota komunitas anime memperlihatkan rentang yang sangat lebar: dari hanya 12 anggota hingga lebih dari satu juta (1.013.917), dengan rata-rata 18.348. Jangkauan luas ini adalah hal yang wajar, merefleksikan tingkat popularitas anime yang sangat bervariasi, dari yang sangat digemari hingga yang kurang diminati

# Multvarite Exploratory Data Analysis
"""

# Count anime rating contribution
anime_rating_contribution = animerating.groupby('anime_id').count()
anime_rating_contribution.head(3)

# Menggabungkan table anime_rating_contribution dengan table anime untuk mendapat nama anime
# Top 10 anime rating contribution
anime2 = anime.drop(['rating'], axis = 'columns')
name_anime_rating_contribution = pd.merge(anime_rating_contribution, anime2, on = 'anime_id', how = 'left')
name_anime_rating_contribution.sort_values(by='user_id', ascending=False).head(10)

print(name_anime_rating_contribution.columns)

# Top 10 Anime Rating Contribution Plot
plt.figure(figsize = (20,15))
top10_anime = name_anime_rating_contribution[['name_y', 'rating_y']].sort_values(by = 'rating_y',ascending = False).head(10)


labels = top10_anime[['name_y']].values.flatten()
values = top10_anime[['rating_y']].values.flatten()

colors = ['#FF0000', '#0000FF', '#FFFF00', '#FF8C00', '#800080', '#008000', '#FF4500', '#1E90FF', '#32CD32', '#BA55D3'] # Define colors here

plt.barh(labels, values, color = colors, edgecolor='black')
plt.grid(linestyle='--', linewidth=2, axis='x', alpha=0.7)
plt.xticks(fontsize = 15)
plt.yticks(fontsize = 15)
plt.title("Top 10 Anime Rating Contribution", fontdict = {'fontsize' : 20})
plt.show()

plt.show()

"""**insight**

kontribusi rating dari 10 anime teratas. Terlihat jelas bahwa "Death Note" memiliki kontribusi rating tertinggi secara signifikan, mendekati 40.000. Diikuti oleh "Sword Art Online" dan "Shingeki no Kyojin" yang juga menunjukkan kontribusi rating yang tinggi, masing-masing di atas 30.000 dan mendekati 30.000. Anime lainnya seperti "Code Geass: Hangyaku no Lelouch", "Elfen Lied", "Angel Beats!", "Naruto", "Fullmetal Alchemist", "Fullmetal Alchemist: Brotherhood", dan "Toradora!" memiliki kontribusi rating yang lebih moderat, berkisar antara 24.000 hingga 27.000. Ini menunjukkan dominasi beberapa judul anime tertentu dalam hal popularitas berdasarkan kontribusi rating.
"""

# Top 10 Anime Community
anime.sort_values(by='members', ascending=False).head(10)

# Top 10 Anime Community Plot
plt.figure(figsize = (20,15))
top10_anime = anime[['name', 'members']].sort_values(by = 'members',ascending = False).head(10)

labels = top10_anime[['name']].values.flatten()
values = top10_anime[['members']].values.flatten()

plt.barh(labels, values, color = colors, edgecolor='black')
plt.grid(color='#95a5a6', linestyle='--', linewidth=2, axis='x', alpha=0.7)
plt.xticks(fontsize = 15)
plt.yticks(fontsize = 15)
plt.title("Top 10 Anime Community", fontdict = {'fontsize' : 20})
plt.show()

plt.show()

"""**insight**

Terlihat bahwa "Death Note" memiliki komunitas terbesar secara signifikan, mencapai hampir 1 juta. "Shingeki no Kyojin" dan "Sword Art Online" juga memiliki komunitas yang sangat besar, masing-masing melebihi 850.000 anggota. Anime lain seperti "Fullmetal Alchemist: Brotherhood" memiliki komunitas yang cukup besar, mendekati 800.000. Sementara itu, "Angel Beats!", "Code Geass: Hangyaku no Lelouch", "Naruto", "Steins;Gate", "Mirai Nikki (TV)", dan "Toradora!" memiliki ukuran komunitas yang relatif lebih kecil, namun tetap besar, dengan angka di atas 600.000. Ini menunjukkan bahwa beberapa anime memiliki basis penggemar yang sangat luas dan aktif dibandingkan dengan yang lain.

# 3. Model Development

* Content Based Filtering

TF- IDF Vectorizer melakukan inisialisasi TfidfVectorizer, kemudian perhitungan idf pada data anime dan melakukan array dari fitur index integer ke fitur nama
"""

tf = TfidfVectorizer()
tf.fit(anime['genre'])
tf.get_feature_names_out()

tfidf_matrix = tf.fit_transform(anime['genre'])
tfidf_matrix.shape

tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=anime.name
).sample(22, axis=1).sample(10, axis=0)

"""* Menghitung cosine similarity pada matrix tf-idf"""

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

cosine_df = pd.DataFrame(cosine_sim, index=anime['name'], columns=anime['name'])
print('Shape:', cosine_df.shape)
cosine_df.sample(10, axis=1).sample(10, axis=0)

"""Dataframe ini menunjukkan nilai kesamaan antar anime berdasarkan nilai cosine similarity. Semakin tinggi nilai dalam sel, semakin tinggi tingkat kesamaan antara anime pada baris dan anime pada kolom.

Misalnya, anime "Nyani ga Nyandaa Nyandaa Kamen" memiliki kesamaan yang cukup tinggi dengan "Tottoko Hamtarou Movie 1: Ham-Ham Land Daibouken" dengan nilai 0.439869, dan juga dengan "Boku wa Tomodachi ga Sukunai Episode 0" dengan nilai 0.22078. Di sisi lain, "Vocaloid China Project Senden Animation" memiliki kesamaan sempurna dengan "Navia Dratp" dengan nilai 1.0, menunjukkan kemiripan yang sangat tinggi atau bahkan duplikat data. Hal ini memungkinkan kita untuk mengidentifikasi anime yang memiliki karakteristik serupa berdasarkan data yang digunakan untuk menghitung kesamaan ini.

# Tes Model Recommendation Content Based Filtering
"""

def anime_recommendations(name, similarity_data=cosine_df, items=anime[['name', 'genre']], k=5):

    index = similarity_data.loc[:,name].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop name agar nama resto yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""**insight**

Fungsi anime_recommendations ini bekerja dengan cara mengambil anime dengan similarity terbesar dari index yang ada.
"""

anime[anime.name.eq('Death Note')]

anime_title = 'Death Note'
anime_recommendations = anime_recommendations(anime_title)
anime_recommendations

"""**Insight**

Sistem telah berhasil merekomendasikan top 5 persen anime yang mirip dengan "Death Note". Berarti jika Anda menyukai alur cerita yang intens, karakter yang cerdas dan kompleks, serta tema-tema psikologis yang mendalam seperti yang ada di "Death Note", Anda akan menemukan rekomendasi ini sangat cocok. Rekomendasi ini akan membuka rekomendasi ke anime lain yang menawarkan pengalaman menonton yang serupa.

---------------------------------------------------------------------------------------------------------------------------------
"""